---
author: Sukhdeep Singh
categories:
- Python
date: May, 21
description: ''
post_status: publish
post_type: post
tags:
- Programming
- Slack
- app development
- tutorials
thumbnailUrl: https://pennow.tech/wp-content/uploads/2021/05/modal-view-title-image.svg
title: 'Slack App with Python: Creating Modal Views [Part-7]'
---

Modal dialogues are visual blocks where the message is displayed in
interactive form. It's composed of various visual elements such as buttons,
date-pickers, and others. This article will discuss how to implement this
feature.

* * *

You read the above statements right. Now might be confused about how modal
views are different from the dialogue messages we discuss in previous
articles. Both are composed of _visual blocks_ messages of the same elements.
Then what's the difference? The answer to your question is that modal
dialogues are different from our previous discussed dialogues in the sense
that these dialogues are raised out of Slack: [caption id="attachment_1511"
align="alignnone" width="857"]![website-monitor-job-creation-
form](https://pennow.tech/wp-content/uploads/2021/05/website-monitor-job-
creation-form.png) Website monitor job creation form[/caption]

## Slack configuration for modal dialogues

It doesn't require any extra entry if you've followed my previous [article on
configuring interactivity.](https://pennow.tech/slack-publishing-ui-
messages/#Slack_configuration_for_Interactivity_feature)

This article is part of: [Most effective way to understand Slack app
development](https://pennow.tech/essential-skills-to-develop-slack-apps/)

To summarize, you must have **interactivity** enabled, and **Request URL
configured** under **Features > Interactive Components**. [caption
id="attachment_1508" align="alignnone" width="801"]![Configure-
interactivity](https://pennow.tech/wp-content/uploads/2021/05/Configure-
interactivity.png) Configure interactivity[/caption]

## Essential features of a model dialogue

Modal views are supported by many parameters. Some are compulsory while others
are optional but help us to customize views. Let's first discuss what all
parameters can help us to define a view. Later we'll discuss how we can update
an existing view.

### Defining a view

To define a view, we have the support of the following parameters.

#### `trigger_id`

To open any view a valid `trigger_id` is a must. Without this, you can't open
a _view_. That's obvious why to start a dialogue unless it's required. Slack
sends `trigger_id` whenever any action occurs whether it's _slash commands,
shortcuts,_ or _button press_. Retrieve `trigger_id` from there, and pass that
to your view.

#### `view`

While `trigger_id` will let you open a view window. This parameter will help
you to define a view. It takes the following parameters.

##### `type`

This is also a must. This will specify how to show your dialogue: `modal` for
modal dialogues and `home` if want to display on Slack's _home tab_

##### `callback_id`

This works as a _view identifier_. Whenever any view is submitted, this
identifier is passed along with the message. In short, this identifier is used
during view submission handler: `@app.view(view_id)`

##### `blocks`

This we already covered in detail in previous articles. This is a JSON text
comprised of various UI elements

##### `title`

As its name suggests, you can specify any text here to display as the title of
your modal dialogue.

##### `submit`

Here, you can specify what text to display for **Submit** button. By default,
it's _Submit_. However, we'll rename it to **Create** as a _signal_ to create
the job. So these were the essential information, which we must/can specify
for a modal view. For more details, you can refer to [Slack's documentation on
modal view fields](https://api.slack.com/reference/surfaces/views).

### Modal view APIs

#### `views.open()`

This method is used to open the view. This asks you to specify `trigger_id`,
and `view` information, which we discussed above.

#### `views.update()`

This method lets you update your currently displayed view with a new view. To
replace your current view, you need `view.id` of that view. This is normally
passed through **action elements** such as buttons, select-boxes, etc. Fetch
`view.id` from there, and pass to `views.update()` method along with `view`
parameter, which lets you specify the new updated view. As the new view will
replace the existing view, so you should fetch the value from the old view,
and pass it to your new view as we'll see soon.

#### `views.push()`

This method lets you push another view over the existing view. The requirement
of this view is the same as was for `views.open()`: `trigger_id` and `view`
parameter.  __Note We'll not be discussing the last two here as we don't have
any such requirement for our current project. However, I'll be posting another
article on these two features.

## Start with implementation

### Implementing job creation view

Now, we've all the information required to create a new view, so let's start
with writing a fresh view. Create a fresh new python file, and [initialize
your slack app](https://pennow.tech/slack-app-getting-
started/#Start_with_implementation):

    
    
    import os
    from dotenv import load_dotenv
    from slack_bolt import App
    
    load_dotenv()
    
    app = App(
        token=os.environ.get("SLACK_API_TOKEN"),
        signing_secret=os.environ.get("SLACK_SIGNING_SECRET")
    )
    ...
    ...
    if __name__ == '__main__':
        app.start(port=5000)
    

We'll be displaying our view when a user enters [`/webmonitor` the slash
command](https://pennow.tech/slack-slash-commands/). Add corresponding command
handler:

    
    
    @app.command("/webmonitor")
    def webmonitor_command_handler(ack, payload, client):
        ack()
        
        client.views_open(
            trigger_id=payload["trigger_id"],
            view={
                "type": "modal",
                "callback_id": "monitoring_job_view",
                "title": {"type": "plain_text", "text": "Website Monitoring"},
                "submit": {"type": "plain_text", "text": "Create"},
                "blocks": get_dialog_data().get('blocks')
            }
        )
    

All of these parameters we already discussed above. If you still need any
clarification, please let me know by clicking the comment button here: Now,
run your app, and send `/webmonitor` command from Slack. You should view a
beautiful dialogue window as shown below: [caption id="attachment_1511"
align="alignnone" width="857"]![website-monitor-job-creation-
form](https://pennow.tech/wp-content/uploads/2021/05/website-monitor-job-
creation-form.png) Website monitor job creation form[/caption]  __Note! If you
can't receive any message, then make sure your [ngrok web server is running
and the session didn't expire](https://pennow.tech/handling-slack-
events/#Working_with_ngrok). Just like we did for `/webmonitor create`
earlier, let's open this view only when the user specifically mentions it.

    
    
    def job_create_view():
        view_data = {
          "type": "modal",
          "callback_id": "monitoring_job_view",
          "title": {
            "type": "plain_text",
            "text": "Website Monitoring"
          },
          "submit": {
            "type": "plain_text",
            "text": "Create"
          },
          "blocks": [
            {
              "type": "header",
              "text": {
                "type": "plain_text",
                "text": "Web Monitoring Configuration"
              }
            },
            {
              "type": "input",
              "block_id": "url_input_block",
              "element": {
                "type": "plain_text_input",
                "action_id": "sl_input",
                "placeholder": {
                  "type": "plain_text",
                  "text": "Enter URL"
                }
              },
              "label": {
                "type": "plain_text",
                "text": "URL"
              },
              "hint": {
                "type": "plain_text",
                "text": "URL of website to be monitored"
              }
            }
          ]
        }
    
        return view_data
    
    
    @app.command("/webmonitor")
    def webmonitor_command_handler(ack, say, payload, client, respond):
        ack()
        command_params = payload.get('text')
    
        if command_params == 'create':
            client.views_open(
                trigger_id=payload["trigger_id"],
                view = job_create_view()
            )
        else:
            respond('Invalid parameters')
    

Firstly, we separated the view specification logic(JSON formatted message)
into a separate function `job_create_view` to ease readability. Secondly, we
invoked our `views_open()`logic only when the user specifically mentions for
`create`.  __Remember JSON for the modal view was retrieved from Slack Builder
Kit. If you didn't get the chance to go through our previous article on [how
to use Slack Builder Kit](https://pennow.tech/slack-publishing-ui-
messages/#Brief_Overview_of_Slack_Block_Kit_Builder), then I'll suggest you go
through that quickly. Now run your app, and enter `/webmonitor create`, and
you should see the modal view opened in the same way as before. Running the
command without any parameter or any unsolicited parameter will only throw an
error: `Invalid parameters`.

### Handling job submission

Whenever a modal view is submitted. it triggered `view_submission` the event.
To listen to that events we must decorate our handler function with
`@app.view()`. _Decorator_ needs a `callback_id` to distinguish itself from
other views as we discussed before. In our case, the _callback id_ specified
was `monitoring_job_view`. [Refer to `job_create_view()` function just above.]
Rest is just fetched and process the information.

    
    
    @app.view('monitoring_job_view')
    def job_submitted(ack, say, respond, body):
        ack()
        user = body["user"]["id"]
        url_val_obj = body['view']['state']['values']['url_input_block']['sl_input']['value']
    
        response = asyncio.run(async_open(url_val))
        say(URL_monitoring_response(response), channel=user)
    

All of the details related to fetch-and-process have already been discussed in
our previous article on [slash command handling](https://pennow.tech/slack-
handling-actions-from-slack-
dialogues/#Implement_feature_to_test_the_website_status). Another point to
note here is that _view submission handlers_ don't contain _channel_
information. So we've to specify them explicitly. Here, a message will be
posted to the user's channel instead of the current channel.  __Notice One
thing to note here is that now our inputs are contained under
`view/state/values/...` instead of `state/values/...` as was in the previous
article.

### Validation error handling

Many times we want to validate the inputs before accepting them. Like in our
current project, we want to validate that a user is entering a valid URL
instead of some garbage text. If validation fails, then we want to display a
nice validation error on the form: [caption id="attachment_1510"
align="alignnone" width="869"]![validation-error-
handling](https://pennow.tech/wp-content/uploads/2021/05/validation-error-
handling.png) Validation error handling[/caption] So how can we handle this ❓
Whenever a view is submitted, we can check the inputs inside our _view
submission_ handler before sending an acknowledgment. If validation fails,
then we send the error message back to Slack through acknowledgment. However,
just like every message, this error message has also a predefined format:

    
    
    {
        "response_action": "errors",
        "errors": {
            "url_input_block": "Please enter a valid URL"
        }
    }
    

The top component is `response_action` specifying that there is an `error`.
Next, we specify `errors` blocks where you need to specify where the error
occurs, and what's the error. So our python implementation will be changed a
little:

    
    
    @app.view('monitoring_job_view')
    def job_submitted(ack, say, respond, client, body):
        url_val = body['view']['state']['values']['url_input_block']['sl_input']['value']
    
        if validate_url(url_val) is None:
            ack({
              "response_action": "errors",
              "errors": {
                "url_input_block": "Please enter a valid URL"
              }
            })
        else:
            ack()
            response = asyncio.run(async_open(url_val))
            say(URL_monitoring_response(response), channel='#web-monitor')
    

The whole code is self-evident. We verified the URL. If failed, then we send
the `ack()` with an error message. Otherwise, we proceeded ahead with our rest
of the process. You must be wondering how I implemented `validate_url()` the
function. Then, I didn't implement it 😄 I just took help from my beloved
[StackOverflow](https://stackoverflow.com/questions/827557/how-do-you-
validate-a-url-with-a-regular-expression-in-python/#answer-7995979). Source
Code: [publish_modal_view.py](https://github.com/pennowtech/slack-app-python-
slack-bolt/blob/master/publish_modal_view.py)

## Summary

This article was a little longer than anticipated. However, I feel that was
the need of the time. I didn't want to miss any important aspect. Now without
any further discussion, let's conclude this article with what all we
discussed:

  * Slack Configuration for modal dialogues
  * few of the important parameters of modal view methods
  * implementation for modal view handlers and submissions
  * in the end, we discussed how to validate errors.

If you need clarification on any topic, please write back to me.

Title image credit: [Vector Vectors by
Vecteezy](https://www.vecteezy.com/free-vector/vector)
